<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>Native Fuzzy Finder in Neovim With Lua and Cool Bindings :: Cherry&#39;s Blog</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Built a native fuzzy finder in neovim to remove yet another plugin and enjoy the latest goods shipped to the main branch." />
<meta name="keywords" content="nvim, fuzzy, finder" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="//localhost:1313/posts/native-fuzzy-finder-in-neovim-with-lua-and-cool-bindings/" />





  
  <link rel="stylesheet" href="//localhost:1313/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/code.min.a3670726bb66927824e4c3fa3f20388aacc1e7aa65014ae144e350ce59593b78.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/main.min.15870410d15d02abd22fb5ef00996f65a00d04b3a7435e9f83831c7c2298de88.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">


<link rel="stylesheet" href="//localhost:1313/terminal.css">




<link rel="shortcut icon" href="//localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Native Fuzzy Finder in Neovim With Lua and Cool Bindings">
<meta property="og:description" content="Built a native fuzzy finder in neovim to remove yet another plugin and enjoy the latest goods shipped to the main branch." />
<meta property="og:url" content="//localhost:1313/posts/native-fuzzy-finder-in-neovim-with-lua-and-cool-bindings/" />
<meta property="og:site_name" content="Cherry&#39;s Blog" />

  <meta property="og:image" content="//localhost:1313/og-image.png">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-08-25 11:25:34 -0300 -03" />












</head>
<body>


<div class="container full">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Cherry&#39;s Blog
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about">About</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about" >About</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="//localhost:1313/posts/native-fuzzy-finder-in-neovim-with-lua-and-cool-bindings/">Native Fuzzy Finder in Neovim With Lua and Cool Bindings</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-08-25&nbsp;[Updated:  2025-08-25]</time><span class="post-author">[Cherry Ramatis]</span><span class="post-reading-time">8 min read (1595 words)</span></div>

  
    <span class="post-tags">
      
      #<a href="//localhost:1313/tags/nvim/">nvim</a>&nbsp;
      
      #<a href="//localhost:1313/tags/tech/">tech</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <p>Since I read a particular <a href="https://yobibyte.github.io/vim.html">blog post by yobibyte</a> about a minimalist approach to neovim configuration I started to think more about how much stuff do I really need for my config to work properly, particularly the main reason why I resonate so much with a particular family of editors (vim, nvim, kakoune, emacs, etc) is the ability to remove as much bloat as you want, keeping only the powerful features that make sense <strong>to you</strong>. It&rsquo;s totally fine to use a neovim distro on the beginning of your journey, but give a chance to start piece by piece, you&rsquo;ll be amazed by how few things you actually need to write and code at your best (If you&rsquo;re interested in this discussion I highly recommend taking a look at the <a href="https://www.youtube.com/watch?v=QMVIJhC9Veg">PDE concept coined by teej_dv</a>.</p>
<blockquote>
<p>First things first, it&rsquo;s important to point out that I&rsquo;m using neovim nightly built from source, this is important because we need two particular patches to make all this work properly, which is this the <a href="https://github.com/vim/vim/pull/17806">vim patch adding wildtrigger() function for cmdline completion</a> (<a href="https://github.com/neovim/neovim/pull/35022">neovim equivalent</a>) and the <a href="https://github.com/vim/vim/pull/15976">vim patch adding findfunc as a option</a> (<a href="https://github.com/zeertzjq/neovim/commit/24d448aeb6cbbe12bb85c7eec3ee0201336b19fa">neovim equivalent</a>).</p></blockquote>
<p>This is the whole module I have at <code>plugin/cmdline.lua</code> for you to copy, we&rsquo;ll break up piece by piece:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> vim.fn.executable <span style="color:#e6db74">&#34;rg&#34;</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_G</span>.<span style="color:#a6e22e">RgFindFiles</span>(cmdarg, _cmdcomplete)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">local</span> fnames <span style="color:#f92672">=</span> vim.fn.systemlist(<span style="color:#e6db74">&#39;rg --files --hidden --color=never --glob=&#34;!.git&#34;&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">#</span>cmdarg <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> fnames
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> vim.fn.matchfuzzy(fnames, cmdarg)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vim.o.findfunc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;v:lua.RgFindFiles&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">is_cmdline_type_find</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> cmdline_cmd <span style="color:#f92672">=</span> vim.fn.split(vim.fn.getcmdline(), <span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;find&#39;</span> <span style="color:#f92672">or</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;fin&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vim.api.nvim_create_autocmd({ <span style="color:#e6db74">&#39;CmdlineChanged&#39;</span>, <span style="color:#e6db74">&#39;CmdlineLeave&#39;</span> }, {
</span></span><span style="display:flex;"><span>    pattern <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#39;*&#39;</span> },
</span></span><span style="display:flex;"><span>    group <span style="color:#f92672">=</span> vim.api.nvim_create_augroup(<span style="color:#e6db74">&#39;CmdlineAutocompletion&#39;</span>, { clear <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span> }),
</span></span><span style="display:flex;"><span>    callback <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(ev)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">should_enable_autocomplete</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">local</span> cmdline_cmd <span style="color:#f92672">=</span> vim.fn.split(vim.fn.getcmdline(), <span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> is_cmdline_type_find() <span style="color:#f92672">or</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;help&#39;</span> <span style="color:#f92672">or</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;h&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ev.event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;CmdlineChanged&#39;</span> <span style="color:#f92672">and</span> should_enable_autocomplete() <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            vim.opt.wildmode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;noselect:lastused,full&#39;</span>
</span></span><span style="display:flex;"><span>            vim.fn.wildtrigger()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ev.event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;CmdlineLeave&#39;</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            vim.opt.wildmode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;full&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;n&#39;</span>, <span style="color:#e6db74">&#39;&lt;leader&gt;f&#39;</span>, <span style="color:#e6db74">&#39;:find&lt;space&gt;&#39;</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Fuzzy find&#39;</span> })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;m-e&gt;&#39;</span>, <span style="color:#e6db74">&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;edit&lt;end&gt;&#39;</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Change command to :edit&#39;</span> })
</span></span><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;m-d&gt;&#39;</span>, <span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_cmdline_type_find() <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        vim.notify(<span style="color:#e6db74">&#39;This binding should be used with :find&#39;</span>, vim.log.levels.ERROR)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> cmdline_arg <span style="color:#f92672">=</span> vim.fn.split(vim.fn.getcmdline(), <span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> vim.uv.fs_realpath(vim.fn.expand(cmdline_arg)) <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        vim.notify(<span style="color:#e6db74">&#39;The second argument should be a valid path&#39;</span>, vim.log.levels.ERROR)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> keys <span style="color:#f92672">=</span> vim.api.nvim_replace_termcodes(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;&lt;C-U&gt;edit &#39;</span> <span style="color:#f92672">..</span> vim.fs.dirname(cmdline_arg),
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    vim.fn.feedkeys(keys, <span style="color:#e6db74">&#39;c&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Edit the dir for the path&#39;</span> })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;c-v&gt;&#39;</span>, <span style="color:#e6db74">&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;vs&lt;end&gt;&#39;</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Change command to :vs&#39;</span> })
</span></span><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;c-s&gt;&#39;</span>, <span style="color:#e6db74">&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;sp&lt;end&gt;&#39;</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Change command to :vs&#39;</span> })
</span></span></code></pre></div><p>And here is a demo showing up all the features:</p>
<p><a href="https://asciinema.org/a/735657"><img src="https://asciinema.org/a/735657.svg" alt="demo"></a></p>
<h2 id="breaking-up-piece-by-piece">Breaking up piece by piece<a href="#breaking-up-piece-by-piece" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>OK, now let&rsquo;s dive in piece by piece. The first thing the should drag your eyes is the <code>findfunc</code> piece, this part is responsible for making the <code>:find</code> command useful in large codebases, with this option we can provide a function that return a list of strings and match as the user type a substring. For our implementation we use exclusively <code>rg --files</code> to get our file list fast and them proceed to fuzzy match using the native vim function <code>matchfuzzy</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">_G</span>.<span style="color:#a6e22e">RgFindFiles</span>(cmdarg, _cmdcomplete)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> fnames <span style="color:#f92672">=</span> vim.fn.systemlist(<span style="color:#e6db74">&#39;rg --files --hidden --color=never --glob=&#34;!.git&#34;&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">#</span>cmdarg <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> fnames
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> vim.fn.matchfuzzy(fnames, cmdarg)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vim.o.findfunc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;v:lua.RgFindFiles&#39;</span>
</span></span></code></pre></div><p>As you can see, the <code>cmdarg</code> is the substring typed by the user so we check if it exists or not, if it does we fuzzy match and if not we just return the full list of files (that happens when the user first type <code>:find &lt;tab&gt;</code>).</p>
<blockquote>
<p>I personally didn&rsquo;t understand the <code>cmdcomplete</code> purpose. It&rsquo;s a boolean parameter and I didn&rsquo;t get the utility from the help pages, if you understood feel free to reach out ^^. For this particular use case it&rsquo;s ok to just ignore it though.</p></blockquote>
<hr>
<p>Now for the cmdline autocompletion bit we&rsquo;ll be using the new <code>wildtrigger()</code> function and enable only for some commands, if you want to enable the autocompletion for any cmdline interaction just use the simpler version of it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>vim.api.nvim_create_autocmd({ <span style="color:#e6db74">&#39;CmdlineChanged&#39;</span> }, {
</span></span><span style="display:flex;"><span>    pattern <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#39;*&#39;</span> },
</span></span><span style="display:flex;"><span>    group <span style="color:#f92672">=</span> vim.api.nvim_create_augroup(<span style="color:#e6db74">&#39;CmdlineAutocompletion&#39;</span>, { clear <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span> }),
</span></span><span style="display:flex;"><span>    callback <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(ev)
</span></span><span style="display:flex;"><span>        vim.opt.wildmenu <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>        vim.opt.wildmode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;noselect:lastused,full&#39;</span>
</span></span><span style="display:flex;"><span>        vim.fn.wildtrigger()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>This <code>wildmode</code> option used here is important to not select the first option even if it&rsquo;s active (with this option, the option will be selected only by pressing <code>&lt;tab&gt;</code>). You can find the whole explanation into `:h wildmode'</p>
<pre tabindex="0"><code class="language-help" data-lang="help">&#34;full&#34;	            Complete the next full match.  Cycles through all
                    matches, returning to the original input after the
                    last match.  If &#39;wildmenu&#39; is enabled, it will be
                    shown.

&#34;noselect:lastused&#34;	Do not preselect the first item in &#39;wildmenu&#39;
				    if it is active.  When completing buffers,
				    sort them by most recently used (excluding the
				    current buffer).
</code></pre><p>For our full implementation we&rsquo;re just adding a layer to enable this behavior when we&rsquo;re on particular commands and disable when we leave the cmdline mode.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">is_cmdline_type_find</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> cmdline_cmd <span style="color:#f92672">=</span> vim.fn.split(vim.fn.getcmdline(), <span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;find&#39;</span> <span style="color:#f92672">or</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;fin&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>vim.api.nvim_create_autocmd({ <span style="color:#e6db74">&#39;CmdlineChanged&#39;</span>, <span style="color:#e6db74">&#39;CmdlineLeave&#39;</span> }, {
</span></span><span style="display:flex;"><span>    pattern <span style="color:#f92672">=</span> { <span style="color:#e6db74">&#39;*&#39;</span> },
</span></span><span style="display:flex;"><span>    group <span style="color:#f92672">=</span> vim.api.nvim_create_augroup(<span style="color:#e6db74">&#39;CmdlineAutocompletion&#39;</span>, { clear <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span> }),
</span></span><span style="display:flex;"><span>    callback <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>(ev)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">local</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">should_enable_autocomplete</span>()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">local</span> cmdline_cmd <span style="color:#f92672">=</span> vim.fn.split(vim.fn.getcmdline(), <span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> is_cmdline_type_find() <span style="color:#f92672">or</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;help&#39;</span> <span style="color:#f92672">or</span> cmdline_cmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;h&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ev.event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;CmdlineChanged&#39;</span> <span style="color:#f92672">and</span> should_enable_autocomplete() <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            vim.opt.wildmode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;noselect:lastused,full&#39;</span>
</span></span><span style="display:flex;"><span>            vim.fn.wildtrigger()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ev.event <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;CmdlineLeave&#39;</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>            vim.opt.wildmode <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;full&#39;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><p>The main parts are the <em>event checking</em> and the <em>cmdline manipulation</em>:</p>
<ul>
<li><em>event checking</em> :: On this version, we&rsquo;re listening for one additional event <code>CmdlineLeave</code> which we use to clean up the <code>wildmode</code> option to the default behavior. To do this we take advantage of the <code>ev</code> passed to the callback, with it we can check the type of the event and perform different actions.</li>
<li><em>cmdline manipulation</em> :: The function <code>vim.fn.getcmdline()</code> return the whole content of the cmdline typed so far, with this we can do a whole lot of string parsing, in this case we&rsquo;re simply splitting into spaces and checking the first word (which is the command).</li>
</ul>
<p>It&rsquo;s done this way because I don&rsquo;t like autocompletion everywhere, so when I&rsquo;m using any regular command (e.g <code>:Ex</code>) I want to keep that default behavior of pressing tab to immediately insert the completion option.</p>
<hr>
<p>Finally reaching for the mappings! Particularly this is the most interesting part if you ask me, it got so much cool features (most of them I got from emacs don&rsquo;t judge)</p>
<p>First let&rsquo;s talk about the command manipulation ones:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;m-e&gt;&#39;</span>, <span style="color:#e6db74">&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;edit&lt;end&gt;&#39;</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Change command to :edit&#39;</span> })
</span></span><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;c-v&gt;&#39;</span>, <span style="color:#e6db74">&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;vs&lt;end&gt;&#39;</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Change command to :vs&#39;</span> })
</span></span><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;c-s&gt;&#39;</span>, <span style="color:#e6db74">&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;sp&lt;end&gt;&#39;</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Change command to :vs&#39;</span> })
</span></span></code></pre></div><p>All of them use the same &ldquo;template&rdquo;, let&rsquo;s look into it more in detail:</p>
<ul>
<li><code>&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;</code> :: This sequence first send the cursor to the beginning of the line (<code>&lt;home&gt;</code>), then navigate one word to the right (<code>&lt;s-right&gt;</code> or <code>shift+right</code>) and finally delete the word from right to left (<code>&lt;c-w&gt;</code> or <code>ctrl+w</code>). Leaving the cmdline without the command, for example <code>:&lt;&lt;cursor_here&gt;&gt; plugin/cmdline.lua</code></li>
<li>word + <code>&lt;end&gt;</code> :: Here is quite straightforward, the <code>word</code> changes from each command and the <code>&lt;end&gt;</code> send the cursor to the end of the line, so you can continue typing or press enter to confirm the command.</li>
</ul>
<p>Now for the more involved one, let&rsquo;s take a look into the <code>&quot;Edit the dir for the path&quot;</code> key bind:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>vim.keymap.set(<span style="color:#e6db74">&#39;c&#39;</span>, <span style="color:#e6db74">&#39;&lt;m-d&gt;&#39;</span>, <span style="color:#66d9ef">function</span>()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_cmdline_type_find() <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        vim.notify(<span style="color:#e6db74">&#39;This binding should be used with :find&#39;</span>, vim.log.levels.ERROR)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> cmdline_arg <span style="color:#f92672">=</span> vim.fn.split(vim.fn.getcmdline(), <span style="color:#e6db74">&#39; &#39;</span>)[<span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> vim.uv.fs_realpath(vim.fn.expand(cmdline_arg)) <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>        vim.notify(<span style="color:#e6db74">&#39;The second argument should be a valid path&#39;</span>, vim.log.levels.ERROR)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">local</span> keys <span style="color:#f92672">=</span> vim.api.nvim_replace_termcodes(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#39;&lt;C-U&gt;edit &#39;</span> <span style="color:#f92672">..</span> vim.fs.dirname(cmdline_arg),
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">true</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    vim.fn.feedkeys(keys, <span style="color:#e6db74">&#39;c&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>, { desc <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Edit the dir for the path&#39;</span> })
</span></span></code></pre></div><p>The initial part parse the whole cmdline string (like we saw earlier about the usage of <code>vim.fn.getcmdline()</code>) to check if the current command is <code>:find</code> and if the second argument is a valid path. We just want to process on these cases.</p>
<p>The editing on this part is a little more tricky because we need to trigger it programmatically instead of just mapping one sequence of characters to another like we did on the last ones. We two main functions <code>vim.api.nvim_replace_termcodes</code> and <code>vim.fn.feedkeys</code> to trigger those characters:</p>
<ul>
<li><code>vim.api.nvim_replace_termcodes</code> :: This function transform special syntax like <code>&lt;c-u&gt;</code> into something neovim can understand while it&rsquo;s feeding keys, it mostly transform these modifiers into <a href="https://en.wikipedia.org/wiki/Escape_sequence">escape sequences</a> like <code>^\U</code></li>
<li><code>vim.fn.feedkeys</code> :: This function pass the sequence of keys and tries to mimic them into the mode specify. For our case it&rsquo;s mimicking the key sequence with the cmdline mode <code>'c'</code></li>
</ul>
<blockquote>
<p>To avoid missing blank spots: The <code>vim.fs.dirname</code> function take a path as an argument and return a path for the parent directory of it, like the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>vim.fs.dirname(<span style="color:#e6db74">&#34;plugin/cmdline.lua&#34;</span>) <span style="color:#75715e">-- &#34;plugin&#34;`</span>
</span></span><span style="display:flex;"><span>vim.fs.dirname(<span style="color:#e6db74">&#34;/home/user/.config/nvim/after/plugin/test.lua&#34;</span>) <span style="color:#75715e">-- &#34;/home/user/.config/nvim/after/plugin/&#34;`</span>
</span></span></code></pre></div></blockquote>
<p>With these functions the behavior is quite similar to the simpler key maps, we first extract the path from the cmdline and them trigger the key sequence <code>&lt;c-u&gt;</code> or <code>ctrl+u</code> which delete the whole line, then we type from the ground up <code>edit</code> followed by the directory path.</p>
<h2 id="conclusion">Conclusion<a href="#conclusion" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<p>Hope this is useful for anyone reading it, I&rsquo;m still exploring more ways to better use native features and will explain it here once I find anything useful like this one. Feel free to reach out and talk about the solution or the quality of the post itself, any tips to improve the solution or my writing is much welcome.</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">Read other posts</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
    
    
      <a href="//localhost:1313/posts/hello-world/" class="button inline next">
         [<span class="button__text">  (format t &#34;Hello World~%&#34;)
  </span>] &gt;
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>


<center>
    <a href="/index.xml">
        <svg aria-hidden="true" width="20" height="20" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss fa-xl " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM96 136c0-13.3 10.7-24 24-24c137 0 248 111 248 248c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-200-200-200c-13.3 0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24c83.9 0 152 68.1 152 152c0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104c-13.3 0-24-10.7-24-24zm0 120a32 32 0 1 1 64 0 32 32 0 1 1 -64 0z"></path></svg>
    </a>

    <a href="https://github.com/cherryramatisdev">
        <svg aria-hidden="true" width="20" height="20" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-xl " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg>
    </a>

    <a href="mailto:cherry.ramatis+contact@gmail.com">
        <svg aria-hidden="true" width="20" height="20" focusable="false" data-prefix="fas" data-icon="square-envelope" class="svg-inline--fa fa-square-envelope fa-xl " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32zM218 271.7L64.2 172.4C66 156.4 79.5 144 96 144l256 0c16.5 0 30 12.4 31.8 28.4L230 271.7c-1.8 1.2-3.9 1.8-6 1.8s-4.2-.6-6-1.8zm29.4 26.9L384 210.4 384 336c0 17.7-14.3 32-32 32L96 368c-17.7 0-32-14.3-32-32l0-125.6 136.6 88.2c7 4.5 15.1 6.9 23.4 6.9s16.4-2.4 23.4-6.9z"></path></svg>
    </a>
</center>


  
</div>

</body>
</html>
