<!doctype html><html lang=en><head><title>Native Fuzzy Finder in Neovim With Lua and Cool Bindings :: Cherry's Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Recently, I read a particular blog post by yobibyte about a no-plugins approach to Neovim configuration, which stuck with me. I started to think more and more about how much stuff I really need for my config to suit my needs. Personally, the main reason why I resonate so much with a particular family of editors (Vim, Nvim, Kakoune, Emacs, etc.) is the ability to add as much stuff as you want, but at the same time the opportunity to remove as much bloat as possible—a little controversial, but if you think about it, it&rsquo;s the best scenario for customizability. I remember watching a video about the concept of a PDE coined by a Neovim contributor called teej_dv, and it really stuck with me. These types of editors are more like an environment than just a product with a single goal.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/native-fuzzy-finder-in-neovim-with-lua-and-cool-bindings/><link rel=stylesheet href=/css/buttons.min.86f6b4c106b6c6eb690ae5203d36b442c1f66f718ff4e8164fa86cf6c61ad641.css><link rel=stylesheet href=/css/code.min.a3670726bb66927824e4c3fa3f20388aacc1e7aa65014ae144e350ce59593b78.css><link rel=stylesheet href=/css/fonts.min.5bb7ed13e1d00d8ff39ea84af26737007eb5051b157b86fc24487c94f3dc8bbe.css><link rel=stylesheet href=/css/footer.min.eb8dfc2c6a7eafa36cd3ba92d63e69e849e2200e0002a228d137f236b09ecd75.css><link rel=stylesheet href=/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css><link rel=stylesheet href=/css/header.min.75c7eb0e2872d95ff48109c6647d0223a38db52e2561dd87966eb5fc7c6bdac6.css><link rel=stylesheet href=/css/main.min.15870410d15d02abd22fb5ef00996f65a00d04b3a7435e9f83831c7c2298de88.css><link rel=stylesheet href=/css/menu.min.3c17467ebeb3d38663dce68f71f519901124fa5cbb4519b2fb0667a21e9aca39.css><link rel=stylesheet href=/css/pagination.min.bbb986dbce00a5ce5aca0504b7925fc1c581992a4bf57f163e5d69cc1db7d836.css><link rel=stylesheet href=/css/post.min.e6dddd258e64c83e05cec0cd49c05216742d42fc8ecbfbe6b67083412b609bd3.css><link rel=stylesheet href=/css/syntax.min.a0773cce9310cb6d8ed23e50f005448facf29a53001b57e038828daa466b25c0.css><link rel=stylesheet href=/css/terminal.min.e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855.css><link rel=stylesheet href=/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css><link rel=stylesheet href=/terminal.css><link rel="shortcut icon" href=/favicon.png><link rel=apple-touch-icon href=/apple-touch-icon.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="Native Fuzzy Finder in Neovim With Lua and Cool Bindings"><meta property="og:description" content="Recently, I read a particular blog post by yobibyte about a no-plugins approach to Neovim configuration, which stuck with me. I started to think more and more about how much stuff I really need for my config to suit my needs. Personally, the main reason why I resonate so much with a particular family of editors (Vim, Nvim, Kakoune, Emacs, etc.) is the ability to add as much stuff as you want, but at the same time the opportunity to remove as much bloat as possible—a little controversial, but if you think about it, it&rsquo;s the best scenario for customizability. I remember watching a video about the concept of a PDE coined by a Neovim contributor called teej_dv, and it really stuck with me. These types of editors are more like an environment than just a product with a single goal.
"><meta property="og:url" content="/posts/native-fuzzy-finder-in-neovim-with-lua-and-cool-bindings/"><meta property="og:site_name" content="Cherry's Blog"><meta property="og:image" content="/og-image.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2025-08-25 00:00:00 +0000 UTC"><link rel=preload href=/NeoSpleen-Regular.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/NeoSpleen-Medium.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/NeoSpleen-Bold.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/syntax-light.css media="screen and (prefers-color-scheme: light)"><link rel=stylesheet href=/syntax-dark.css media="screen and (prefers-color-scheme: dark)"></head><body><div class="container full"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Cherry's Blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about>About</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about>About</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/posts/native-fuzzy-finder-in-neovim-with-lua-and-cool-bindings/>Native Fuzzy Finder in Neovim With Lua and Cool Bindings</a></h1><div class=post-meta><time class=post-date>2025-08-25</time><span class=post-author>[Cherry Ramatis]</span><span class=post-reading-time>11 min read (2186 words)</span></div><span class=post-tags>#<a href=/tags/nvim/>nvim</a>&nbsp;
#<a href=/tags/fuzzy/>fuzzy</a>&nbsp;
#<a href=/tags/finder/>finder</a>&nbsp;</span><div class=post-content><div><p>Recently, I read a particular <a href=https://yobibyte.github.io/vim.html>blog post by yobibyte</a> about a no-plugins approach to Neovim configuration, which stuck with me. I started to think more and more about how much stuff I really need for my config to suit my needs. Personally, the main reason why I resonate so much with a particular family of editors (Vim, Nvim, Kakoune, Emacs, etc.) is the ability to add as much stuff as you want, but at the same time the opportunity to remove as much bloat as possible—a little controversial, but if you think about it, it&rsquo;s the best scenario for customizability. I remember watching a video about the concept of a <a href="https://www.youtube.com/watch?v=QMVIJhC9Veg">PDE</a> coined by a Neovim contributor called teej_dv, and it really stuck with me. These types of editors are more like an environment than just a product with a single goal.</p><p>Well, this is the exact situation I&rsquo;m currently in, trying to experiment with native functions from Neovim and writing tiny wrappers around them instead of using plugins that recreate the whole UX. I hope you find this particular &ldquo;wrapper&rdquo; useful for your workflow. :)</p><blockquote><p>First things first, it&rsquo;s important to point out that I&rsquo;m using neovim nightly, this is important because we need two particular patches to make all this work properly, which is this the <a href=https://github.com/vim/vim/pull/17806>vim patch adding wildtrigger() function for cmdline completion</a> (<a href=https://github.com/neovim/neovim/pull/35022>neovim equivalent</a>) and the <a href=https://github.com/vim/vim/pull/15976>vim patch adding findfunc as a option</a> (<a href=https://github.com/neovim/neovim/pull/31058>neovim equivalent</a>). If at the time you&rsquo;re reading this post those patches are already available at stable version, you don&rsquo;t need to worry with building from source.</p></blockquote><p>For the ones with a practical sense, this is the whole module I have at <code>plugin/cmdline.lua</code> for you to copy and try for yourself. Throughout this blog post, we&rsquo;ll break up piece by piece how it works.</p><p>You can also find a vim9 version that originated all my thoughts around this theme: <a href=https://www.reddit.com/r/vim/comments/1mvzitt/yet_another_simple_fuzzy_file_finder/>https://www.reddit.com/r/vim/comments/1mvzitt/yet_another_simple_fuzzy_file_finder/</a></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=line><span class=cl><span class=kr>if</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>executable</span> <span class=s2>&#34;rg&#34;</span> <span class=o>==</span> <span class=mi>1</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>    <span class=kr>function</span> <span class=nc>_G</span><span class=p>.</span><span class=nf>RgFindFiles</span><span class=p>(</span><span class=n>cmdarg</span><span class=p>,</span> <span class=n>_cmdcomplete</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>local</span> <span class=n>fnames</span> <span class=o>=</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>systemlist</span><span class=p>(</span><span class=s1>&#39;rg --files --hidden --color=never --glob=&#34;!.git&#34;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kr>if</span> <span class=o>#</span><span class=n>cmdarg</span> <span class=o>==</span> <span class=mi>0</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>            <span class=kr>return</span> <span class=n>fnames</span>
</span></span><span class=line><span class=cl>        <span class=kr>else</span>
</span></span><span class=line><span class=cl>            <span class=kr>return</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>matchfuzzy</span><span class=p>(</span><span class=n>fnames</span><span class=p>,</span> <span class=n>cmdarg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kr>end</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>vim.o</span><span class=p>.</span><span class=n>findfunc</span> <span class=o>=</span> <span class=s1>&#39;v:lua.RgFindFiles&#39;</span>
</span></span><span class=line><span class=cl><span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>local</span> <span class=kr>function</span> <span class=nf>is_cmdline_type_find</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>cmdline_cmd</span> <span class=o>=</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=n>vim.fn</span><span class=p>.</span><span class=n>getcmdline</span><span class=p>(),</span> <span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>return</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;find&#39;</span> <span class=ow>or</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;fin&#39;</span>
</span></span><span class=line><span class=cl><span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_create_autocmd</span><span class=p>({</span> <span class=s1>&#39;CmdlineChanged&#39;</span><span class=p>,</span> <span class=s1>&#39;CmdlineLeave&#39;</span> <span class=p>},</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pattern</span> <span class=o>=</span> <span class=p>{</span> <span class=s1>&#39;*&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>group</span> <span class=o>=</span> <span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_create_augroup</span><span class=p>(</span><span class=s1>&#39;CmdlineAutocompletion&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>clear</span> <span class=o>=</span> <span class=kc>true</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>    <span class=n>callback</span> <span class=o>=</span> <span class=kr>function</span><span class=p>(</span><span class=n>ev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>local</span> <span class=kr>function</span> <span class=nf>should_enable_autocomplete</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=kd>local</span> <span class=n>cmdline_cmd</span> <span class=o>=</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=n>vim.fn</span><span class=p>.</span><span class=n>getcmdline</span><span class=p>(),</span> <span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=kr>return</span> <span class=n>is_cmdline_type_find</span><span class=p>()</span> <span class=ow>or</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;help&#39;</span> <span class=ow>or</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;h&#39;</span>
</span></span><span class=line><span class=cl>        <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kr>if</span> <span class=n>ev.event</span> <span class=o>==</span> <span class=s1>&#39;CmdlineChanged&#39;</span> <span class=ow>and</span> <span class=n>should_enable_autocomplete</span><span class=p>()</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>            <span class=n>vim.opt</span><span class=p>.</span><span class=n>wildmode</span> <span class=o>=</span> <span class=s1>&#39;noselect:lastused,full&#39;</span>
</span></span><span class=line><span class=cl>            <span class=n>vim.fn</span><span class=p>.</span><span class=n>wildtrigger</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kr>if</span> <span class=n>ev.event</span> <span class=o>==</span> <span class=s1>&#39;CmdlineLeave&#39;</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>            <span class=n>vim.opt</span><span class=p>.</span><span class=n>wildmode</span> <span class=o>=</span> <span class=s1>&#39;full&#39;</span>
</span></span><span class=line><span class=cl>        <span class=kr>end</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;n&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;leader&gt;f&#39;</span><span class=p>,</span> <span class=s1>&#39;:find&lt;space&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Fuzzy find&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;m-e&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;edit&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :edit&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;m-d&gt;&#39;</span><span class=p>,</span> <span class=kr>function</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=kr>if</span> <span class=ow>not</span> <span class=n>is_cmdline_type_find</span><span class=p>()</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>        <span class=n>vim.notify</span><span class=p>(</span><span class=s1>&#39;This binding should be used with :find&#39;</span><span class=p>,</span> <span class=n>vim.log</span><span class=p>.</span><span class=n>levels.ERROR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kr>return</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>cmdline_arg</span> <span class=o>=</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=n>vim.fn</span><span class=p>.</span><span class=n>getcmdline</span><span class=p>(),</span> <span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>if</span> <span class=n>vim.uv</span><span class=p>.</span><span class=n>fs_realpath</span><span class=p>(</span><span class=n>vim.fn</span><span class=p>.</span><span class=n>expand</span><span class=p>(</span><span class=n>cmdline_arg</span><span class=p>))</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>        <span class=n>vim.notify</span><span class=p>(</span><span class=s1>&#39;The second argument should be a valid path&#39;</span><span class=p>,</span> <span class=n>vim.log</span><span class=p>.</span><span class=n>levels.ERROR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kr>return</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>keys</span> <span class=o>=</span> <span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_replace_termcodes</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;&lt;C-U&gt;edit &#39;</span> <span class=o>..</span> <span class=n>vim.fs</span><span class=p>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>cmdline_arg</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>vim.fn</span><span class=p>.</span><span class=n>feedkeys</span><span class=p>(</span><span class=n>keys</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kr>end</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Edit the dir for the path&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;c-v&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;vs&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :vs&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;c-s&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;sp&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :sp&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;c-t&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;tabe&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :tabe&#39;</span> <span class=p>})</span>
</span></span></code></pre></div><p>And here is a demo showing off all the features available:</p><blockquote><p>Disclaimer: The screenkey plugin here is a bit laggy so consider referencing the keybinds with the code block above if something was confusing.</p></blockquote><figure><a href=https://asciinema.org/a/735657><img src=https://asciinema.org/a/735657.svg></a></figure><h2 id=breaking-up-piece-by-piece>Breaking up piece by piece<a href=#breaking-up-piece-by-piece class=hanchor arialabel=Anchor>#</a></h2><p>OK! Time to dive into this module. The first feature that honestly made all this even possible is the simplest to explain: the <code>findfunc</code> option. This patch was merged into Neovim in November 2024 from a Vim patch and introduced the possibility of customizing how the editor searched files using the <code>:find</code> cmd.</p><p>Historically, Vim users that wanted a more native file finder were using a rather hacky trick that consisted of configuring the <code>path</code> option with a glob pattern like this: <code>set path+=**</code>. By adding this, the <code>:find</code> command could expand to the whole project structure to find a file. The problem? Performance: It&rsquo;s quite slow using the GNU find binaries in large codebases.</p><p>But with <code>findfunc</code>, we can make this command use faster binaries like <code>fd</code>, <code>rg</code> or even using our favorite VCS like <code>git ls-files</code> to increase the initial performance hit of loading the files. Basically, we have a functional file finder now! Yay!</p><p>All this is nice, but it&rsquo;s missing one important piece to the function: fuzzy matching. You know, that thing that makes the telescope plugin really shine, that allows you to type roughly the file name and still get the correct matches? We can achieve this by using the <code>matchfuzzy</code> to further filter the options as the user types.</p><p>This sums up our first function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=line><span class=cl><span class=kr>function</span> <span class=nc>_G</span><span class=p>.</span><span class=nf>RgFindFiles</span><span class=p>(</span><span class=n>cmdarg</span><span class=p>,</span> <span class=n>_cmdcomplete</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>fnames</span> <span class=o>=</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>systemlist</span><span class=p>(</span><span class=s1>&#39;rg --files --hidden --color=never --glob=&#34;!.git&#34;&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kr>if</span> <span class=o>#</span><span class=n>cmdarg</span> <span class=o>==</span> <span class=mi>0</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>        <span class=kr>return</span> <span class=n>fnames</span>
</span></span><span class=line><span class=cl>    <span class=kr>else</span>
</span></span><span class=line><span class=cl>        <span class=kr>return</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>matchfuzzy</span><span class=p>(</span><span class=n>fnames</span><span class=p>,</span> <span class=n>cmdarg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl><span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vim.o</span><span class=p>.</span><span class=n>findfunc</span> <span class=o>=</span> <span class=s1>&#39;v:lua.RgFindFiles&#39;</span>
</span></span></code></pre></div><p>As you can see, the <code>cmdarg</code> is the substring typed by the user (it&rsquo;s nil when the user didn&rsquo;t type anything). For this function, we separate into returning the whole list of files when the user hasn&rsquo;t typed anything yet and returning the fuzzy matched list according to the substring provided. The function will be called every time the user manually presses the <code>&lt;tab></code> key, and all the details regarding the limit of items shown and navigation are dealt with by the <code>wildmenu</code> option (you can find more about it with <code>:h wildmenu</code>)</p><hr><p>Nice! We now have tab-completed fuzzy finding; let&rsquo;s spice things up with ✨ autocompletion ✨. I&rsquo;m not a particular fan of autocompletion when I&rsquo;m typing on a buffer, but it certainly fits perfectly when filtering file paths.</p><p>For this to be possible comes our second patch that introduced the <code>wildtrigger()</code> function. It is quite simple in theory: it triggers completion programmatically when on the cmdline, it works for commands like <code>/</code> <code>:s</code> and, of course, <code>:find</code>. When combined with the autocmd event <code>CmdlineChanged</code> we can programmatically trigger the completion every time we type a character into the cmdline, cool, right?</p><p>The simplest version of this behavior can be declared as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=line><span class=cl><span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_create_autocmd</span><span class=p>({</span> <span class=s1>&#39;CmdlineChanged&#39;</span> <span class=p>},</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pattern</span> <span class=o>=</span> <span class=p>{</span> <span class=s1>&#39;*&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>group</span> <span class=o>=</span> <span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_create_augroup</span><span class=p>(</span><span class=s1>&#39;CmdlineAutocompletion&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>clear</span> <span class=o>=</span> <span class=kc>true</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>    <span class=n>callback</span> <span class=o>=</span> <span class=kr>function</span><span class=p>(</span><span class=n>ev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>vim.opt</span><span class=p>.</span><span class=n>wildmenu</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=n>vim.opt</span><span class=p>.</span><span class=n>wildmode</span> <span class=o>=</span> <span class=s1>&#39;noselect:lastused,full&#39;</span>
</span></span><span class=line><span class=cl>        <span class=n>vim.fn</span><span class=p>.</span><span class=n>wildtrigger</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><blockquote><p>You can move the `wildmenu` and `wildmode` configuration outside the autocmd without any problems, we&rsquo;re just containing more in favor of control and simplicity.</p></blockquote><p>Together with the <code>wildtrigger</code> function being called on every change, we have a neat setting being placed here: the <code>wildmode</code>. This option is important because it allows us to not immediately insert the first option when the completion popup appears; it&rsquo;s similar to what we set in <code>completeopt</code> to configure buffer autocompletion frameworks like <a href=https://github.com/hrsh7th/nvim-cmp>nvim-cmp</a>.</p><p>For context, let&rsquo;s take a look into the full description for this option from the help pages:</p><pre tabindex=0><code class=language-help data-lang=help>&#34;full&#34;	            Complete the next full match.  Cycles through all
                    matches, returning to the original input after the
                    last match.  If &#39;wildmenu&#39; is enabled, it will be
                    shown.

&#34;noselect:lastused&#34;	Do not preselect the first item in &#39;wildmenu&#39;
				    if it is active.  When completing buffers,
				    sort them by most recently used (excluding the
				    current buffer).
</code></pre><p>This is already our full feature of fuzzy finding with autocomplete! Further on in this article, we&rsquo;ll write keymaps around the cmdline mode to improve the UX, shall we? :)</p><p>First let&rsquo;s constrain this autocomplete to work on specific commands. This is particularly useful to me because I don&rsquo;t want autocompletion in commands like <code>:edit</code>, just on the ones important to fuzzy finding (in this case, <code>:help</code> and <code>:find</code>).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=line><span class=cl><span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_create_autocmd</span><span class=p>({</span> <span class=s1>&#39;CmdlineChanged&#39;</span><span class=p>,</span> <span class=s1>&#39;CmdlineLeave&#39;</span> <span class=p>},</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pattern</span> <span class=o>=</span> <span class=p>{</span> <span class=s1>&#39;*&#39;</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>group</span> <span class=o>=</span> <span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_create_augroup</span><span class=p>(</span><span class=s1>&#39;CmdlineAutocompletion&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>clear</span> <span class=o>=</span> <span class=kc>true</span> <span class=p>}),</span>
</span></span><span class=line><span class=cl>    <span class=n>callback</span> <span class=o>=</span> <span class=kr>function</span><span class=p>(</span><span class=n>ev</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>local</span> <span class=kr>function</span> <span class=nf>should_enable_autocomplete</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=kd>local</span> <span class=n>cmdline_cmd</span> <span class=o>=</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=n>vim.fn</span><span class=p>.</span><span class=n>getcmdline</span><span class=p>(),</span> <span class=s1>&#39; &#39;</span><span class=p>)[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>-- NOTE: Here your can add any other variant that you commonly type to abbreviate the command. :)</span>
</span></span><span class=line><span class=cl>            <span class=kr>return</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;find&#39;</span> <span class=ow>or</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;fin&#39;</span> <span class=ow>or</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;help&#39;</span> <span class=ow>or</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;h&#39;</span>
</span></span><span class=line><span class=cl>        <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kr>if</span> <span class=n>ev.event</span> <span class=o>==</span> <span class=s1>&#39;CmdlineChanged&#39;</span> <span class=ow>and</span> <span class=n>should_enable_autocomplete</span><span class=p>()</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>            <span class=n>vim.opt</span><span class=p>.</span><span class=n>wildmode</span> <span class=o>=</span> <span class=s1>&#39;noselect:lastused,full&#39;</span>
</span></span><span class=line><span class=cl>            <span class=n>vim.fn</span><span class=p>.</span><span class=n>wildtrigger</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kr>if</span> <span class=n>ev.event</span> <span class=o>==</span> <span class=s1>&#39;CmdlineLeave&#39;</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>            <span class=n>vim.opt</span><span class=p>.</span><span class=n>wildmode</span> <span class=o>=</span> <span class=s1>&#39;full&#39;</span>
</span></span><span class=line><span class=cl>        <span class=kr>end</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>There are two main aspects of this version, the <strong>cleanup</strong> and the <strong>cmdline check</strong>:</p><dl><dt><em>cleanup</em></dt><dd>On this version, we&rsquo;re listening to an additional event <code>CmdlineLeave</code> which we use to reset the <code>wildmode</code> option to the default value. This is important to not affect further commands on the cmdline. To do that, we take advantage of the <code>ev</code> parameter passed to the callback; with it we can check the <code>.event</code> and perform different actions.</dd><dt><em>cmdline check</em></dt><dd>With the function <code>vim.fn.getcmdline()</code> we get the whole content of the cmdline typed so far as a string, considering that it is just a matter of string parsing to get the parts we want. To keep it simple, we&rsquo;re just splitting on spaces and checking the first word (the command).</dd></dl><p>Great! Our current version has a controlled autocompletion based on the command and a fuzzy finding method attached to it. What else is needed? Now we&rsquo;ll add the convenient strategies implied by plugin fuzzy finders to open the selection on splits and other cool additions that worked for me personally.</p><p>I need to be honest here; some of these keymaps I got the idea from Emacs (no judgments), and it suited so well with this finder. Some of them are quite simple, and we&rsquo;ll start off with them!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;m-e&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;edit&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :edit&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;c-v&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;vs&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :vs&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;c-s&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;sp&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :sp&#39;</span> <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;c-t&gt;&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;home&gt;&lt;s-right&gt;&lt;c-w&gt;tabe&lt;end&gt;&#39;</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Change command to :tabe&#39;</span> <span class=p>})</span>
</span></span></code></pre></div><p>Quite simple, right? All of them do the same thing: they change the command to achieve different actions like opening on a split, a tab, etc. Let&rsquo;s break the syntax briefly:</p><dl><dt><code>&lt;home>&lt;s-right>&lt;c-w></code></dt><dd>This sequence first sends the cursor to the beginning of the line (<code>&lt;home></code>), then navigates one word to the right (<code>&lt;s-right></code> or <code>shift+right</code>) and finally deletes the word from right to left (<code>&lt;c-w></code> or <code>ctrl+w</code>). Leaving the cmdline without the command, for example, <code>:&lt;&lt;cursor_here>> plugin/cmdline.lua</code></dd><dt>word + <code>&lt;end></code></dt><dd>Here it is quite straightforward; the <code>word</code> changes from each command, and the <code>&lt;end></code> sends the cursor to the end of the line, so you can continue typing or press enter to confirm the command.</dd></dl><p>Got it? These bindings already bring up the functionalities provided by common fuzzy finders, but let&rsquo;s go a little further with an additional keymap: manipulate the current path to get the directory instead. The purpose is to easily open the directory for a file to move/copy/delete something.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-lua data-lang=lua><span class=line><span class=cl><span class=n>vim.keymap</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=s1>&#39;c&#39;</span><span class=p>,</span> <span class=s1>&#39;&lt;m-d&gt;&#39;</span><span class=p>,</span> <span class=kr>function</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>cmdline</span> <span class=o>=</span> <span class=n>vim.fn</span><span class=p>.</span><span class=n>split</span><span class=p>(</span><span class=n>vim.fn</span><span class=p>.</span><span class=n>getcmdline</span><span class=p>(),</span> <span class=s1>&#39; &#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>cmdline_cmd</span> <span class=o>=</span> <span class=n>cmdline</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>if</span> <span class=ow>not</span> <span class=p>(</span><span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;find&#39;</span> <span class=ow>or</span> <span class=n>cmdline_cmd</span> <span class=o>==</span> <span class=s1>&#39;fin&#39;</span><span class=p>)</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>        <span class=n>vim.notify</span><span class=p>(</span><span class=s1>&#39;This binding should be used with :find&#39;</span><span class=p>,</span> <span class=n>vim.log</span><span class=p>.</span><span class=n>levels.ERROR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kr>return</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>cmdline_arg</span> <span class=o>=</span> <span class=n>cmdline</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>if</span> <span class=n>vim.uv</span><span class=p>.</span><span class=n>fs_realpath</span><span class=p>(</span><span class=n>vim.fn</span><span class=p>.</span><span class=n>expand</span><span class=p>(</span><span class=n>cmdline_arg</span><span class=p>))</span> <span class=o>==</span> <span class=kc>nil</span> <span class=kr>then</span>
</span></span><span class=line><span class=cl>        <span class=n>vim.notify</span><span class=p>(</span><span class=s1>&#39;The second argument should be a valid path&#39;</span><span class=p>,</span> <span class=n>vim.log</span><span class=p>.</span><span class=n>levels.ERROR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kr>return</span>
</span></span><span class=line><span class=cl>    <span class=kr>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>local</span> <span class=n>keys</span> <span class=o>=</span> <span class=n>vim.api</span><span class=p>.</span><span class=n>nvim_replace_termcodes</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=s1>&#39;&lt;C-U&gt;edit &#39;</span> <span class=o>..</span> <span class=n>vim.fs</span><span class=p>.</span><span class=n>dirname</span><span class=p>(</span><span class=n>cmdline_arg</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kc>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>vim.fn</span><span class=p>.</span><span class=n>feedkeys</span><span class=p>(</span><span class=n>keys</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kr>end</span><span class=p>,</span> <span class=p>{</span> <span class=n>desc</span> <span class=o>=</span> <span class=s1>&#39;Edit the dir for the path&#39;</span> <span class=p>})</span>
</span></span></code></pre></div><p>The initial part parses the whole cmdline string (like we saw earlier about the usage of <code>vim.fn.getcmdline()</code>) to check if the current command is <code>:find</code> and if the second argument is a valid path. We just want to process these cases.</p><p>The cmdline manipulation on this part is a little trickier because instead of just outputting the special syntax like the previous keymaps, we need to do it programmatically. For this to be possible, we need two important functions: <code>vim.api.nvim_replace_termcodes</code> and <code>vim.fn.feedkeys</code>.</p><dl><dt><code>vim.api.nvim_replace_termcodes</code></dt><dd>This function transforms special syntax like <code>&lt;c-u></code> into a version commonly used in shells; it mostly transforms these modifiers into <a href=https://en.wikipedia.org/wiki/Escape_sequence>escape sequences</a> like <code>^\U</code> for <code>ctrl+u</code>.</dd><dt><code>vim.fn.feedkeys</code></dt><dd>This function passes the sequence of keys and tries to mimic them into the mode specified. For our case it&rsquo;s mimicking the key sequence with the cmdline mode <code>'c'</code>. It emulates what would happen if you had typed that sequence manually.</dd></dl><blockquote><p>Another important function is the `vim.fs.dirname` one, this function receive a path as argument and return the path to the parent directory of it, like the following:</p><p>```lua
vim.fs.dirname(&ldquo;plugin/cmdline.lua&rdquo;) &ndash; &ldquo;plugin&rdquo;`
vim.fs.dirname("<em>home/user</em>.config/nvim/after/plugin/test.lua") &ndash; &ldquo;<em>home/user</em>.config/nvim/after/plugin/&rdquo;`
```</p></blockquote><p>Having explained these functions, we can sum up the behavior of the binding like the following: For the <code>:find</code> command, by pressing <code>option+d</code> or <code>alt+d</code> we replace the path with the parent directory version of it, allowing you to open your file browser of choice.</p><blockquote><p>The <code>&lt;c-u></code> or <code>ctrl+u</code> triggered from the function delete the content of the whole line.</p></blockquote><h2 id=final-thoughts>Final thoughts<a href=#final-thoughts class=hanchor arialabel=Anchor>#</a></h2><p>I hope some of this is useful for you reading it! Either by knowing a new function or some interesting behavior that you didn&rsquo;t know about nvim, the main goal with these explorations is to know more about the editor we all use every day. Feel free to reach out so we can talk more about this topic. :) May the Force be with you. 🍒.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><a href=/posts/quick-tip-for-the-week-1-making-netrw-more-usable/ class="button inline prev">&lt; [<span class=button__text>Quick Tip for the Week #1: Making Netrw More Usable</span>]
</a>::
<a href=/posts/hello-world/ class="button inline next">[<span class=button__text> (format t "Hello world~%")
</span>] ></a></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2025 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script><center><a href=/index.xml aria-label="RSS Feed"><svg aria-hidden="true" width="20" height="20" focusable="false" data-prefix="fas" data-icon="square-rss" class="svg-inline--fa fa-square-rss fa-xl" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M64 32C28.7 32 0 60.7.0 96V416c0 35.3 28.7 64 64 64h320c35.3.0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM96 136c0-13.3 10.7-24 24-24 137 0 248 111 248 248 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-110.5-89.5-2e2-2e2-2e2-13.3.0-24-10.7-24-24zm0 96c0-13.3 10.7-24 24-24 83.9.0 152 68.1 152 152 0 13.3-10.7 24-24 24s-24-10.7-24-24c0-57.4-46.6-104-104-104-13.3.0-24-10.7-24-24zm0 120a32 32 0 1164 0 32 32 0 11-64 0z"/></svg>
</a><a href=https://github.com/cherryramatisdev aria-label="My github profile"><svg aria-hidden="true" width="20" height="20" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-xl" role="img" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</a><a href=mailto:cherry.ramatis+contact@gmail.com aria-label="Email me to reach contact"><svg aria-hidden="true" width="20" height="20" focusable="false" data-prefix="fas" data-icon="square-envelope" class="svg-inline--fa fa-square-envelope fa-xl" role="img" viewBox="0 0 448 512"><path fill="currentcolor" d="M64 32C28.7 32 0 60.7.0 96V416c0 35.3 28.7 64 64 64h320c35.3.0 64-28.7 64-64V96c0-35.3-28.7-64-64-64H64zM218 271.7 64.2 172.4C66 156.4 79.5 144 96 144h256c16.5.0 30 12.4 31.8 28.4L230 271.7c-1.8 1.2-3.9 1.8-6 1.8s-4.2-.6-6-1.8zm29.4 26.9L384 210.4V336c0 17.7-14.3 32-32 32H96c-17.7.0-32-14.3-32-32V210.4l136.6 88.2c7 4.5 15.1 6.9 23.4 6.9s16.4-2.4 23.4-6.9z"/></svg></a></center></div></body></html>